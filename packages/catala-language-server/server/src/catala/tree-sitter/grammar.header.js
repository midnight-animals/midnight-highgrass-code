const name = "Catala"

var lang = "en"
if ('TREESITTER_CATALA_LANG' in process.env) {
  lang = process.env.TREESITTER_CATALA_LANG
}

const tokens_local = {
  en: {
    SCOPE: "scope",
    CONSEQUENCE: "consequence",
    DATA: "data",
    DEPENDS: /depends\s+on/,
    DECLARATION: "declaration",
    CONTEXT: "context",
    DECREASING: "decreasing",
    INCREASING: "increasing",
    OF: "of",
    COLLECTION: "collection",
    ENUM: "enumeration",
    INTEGER: "integer",
    MONEY: "money",
    TEXT: "text",
    DECIMAL: "decimal",
    DATE: "date",
    DURATION: "duration",
    BOOLEAN: "boolean",
    SUM: "sum",
    FILLED: "fulfilled",
    DEFINITION: "definition",
    STATE: "state",
    LABEL: "label",
    EXCEPTION: "exception",
    DEFINED_AS: "equals",
    MATCH: "match",
    WILDCARD: "anything",
    WITH: /with\s+pattern/,
    UNDER_CONDITION: /under\s+condition/,
    IF: "if",
    THEN: "then",
    ELSE: "else",
    CONDITION: "condition",
    CONTENT: "content",
    STRUCT: "structure",
    ASSERTION: "assertion",
    VARIES: "varies",
    WITH_V: "with",
    FOR: "for",
    ALL: "all",
    WE_HAVE: /we\s+have/,
    FIXED: "fixed",
    BY: "by",
    RULE: "rule",
    EXISTS: "exists",
    IN: "in",
    SUCH: "such",
    THAT: "that",
    AND: "and",
    OR: "or",
    XOR: "xor",
    NOT: "not",
    MAXIMUM: "maximum",
    MINIMUM: "minimum",
    FILTER: "filter",
    MAP: "map",
    INIT: "initial",
    CARDINAL: "number",
    YEAR: "year",
    MONTH: "month",
    DAY: "day",
    TRUE: "true",
    FALSE: "false",
    INPUT: "input",
    OUTPUT: "output",
    INTERNAL: "internal",
    RoundMoney: "round_money",
    RoundDecimal: "round_decimal",
    IntToDec: "integer_to_decimal",
    GetDay: "get_day",
    GetMonth: "get_month",
    GetYear: "get_year",
    FirstDayOfMonth: "first_day_of_month",
    LastDayOfMonth: "last_day_of_month",
    DECIMAL_LITERAL: /[0-9]+\.[0-9]*/,
    MONEY_AMOUNT: /\$[0-9]([0-9,]*[0-9])?(\.[0-9]{0,2})?/,
    DIVMONEY: '/$',
    GREATER_EQUAL_MONEY: '>=$',
    GREATER_MONEY: '>$',
    LESSER_EQUAL_MONEY: '<=$',
    LESSER_MONEY: '<$',
    MINUSMONEY: '-$',
    MULTMONEY: '*$',
    PLUSMONEY: '+$',
    LAW_INCLUDE: 'Include',
  },
  fr: {
    SCOPE: "champ\s+d'application",
    CONSEQUENCE: "conséquence",
    DATA: "donnée",
    DEPENDS: "dépend\s+de",
    DECLARATION: "déclaration",
    CONTEXT: "contexte",
    DECREASING: "décroissant",
    INCREASING: "croissant",
    OF: "de",
    COLLECTION: "collection",
    CONTAINS: "contient",
    ENUM: "énumération",
    INTEGER: "entier",
    MONEY: "argent",
    TEXT: "texte",
    DECIMAL: "décimal",
    DATE: "date",
    DURATION: "durée",
    BOOLEAN: "booléen",
    SUM: "somme",
    FILLED: "rempli",
    DEFINITION: "définition",
    STATE: "état",
    LABEL: "étiquette",
    EXCEPTION: "exception",
    DEFINED_AS: "égal\s+à",
    MATCH: "selon",
    WILDCARD: "n'importe\s+quel",
    WITH: "sous\s+forme",
    UNDER_CONDITION: "sous\s+condition",
    IF: "si",
    THEN: "alors",
    ELSE: "sinon",
    CONDITION: "condition",
    CONTENT: "contenu",
    STRUCT: "structure",
    ASSERTION: "assertion",
    VARIES: "varie",
    WITH_V: "avec",
    FOR: "pour",
    ALL: "tout",
    WE_HAVE: "on\s+a",
    FIXED: "fixé",
    BY: "par",
    RULE: "règle",
    EXISTS: "existe",
      IN: "dans",
    SUCH: "tel",
    THAT: "que",
    AND: "et",
    OR: "ou",
    XOR: "ou\s+bien",
    NOT: "non",
    MAXIMUM: "maximum",
    MINIMUM: "minimum",
    FILTER: "filtre",
    MAP: "application",
    INIT: "initial",
    CARDINAL: "nombre",
    YEAR: "an",
    MONTH: "mois",
    DAY: "jour",
    TRUE: "vrai",
    FALSE: "faux",
    INPUT: "entrée",
    OUTPUT: "sortie",
    INTERNAL: "interne",
    RoundMoney: "arrondi_argent",
    RoundDecimal: "arrondi_décimal",
    IntToDec: "entier_vers_décimal",
    MoneyToDec: "argent_vers_décimal",
    DecToMoney: "décimal_vers_argent",
    GetDay: "accès_jour",
    GetMonth: "accès_mois",
    GetYear: "accès_année",
    FirstDayOfMonth: "premier_jour_du_mois",
    LastDayOfMonth: "dernier_jour_du_mois",
    DECIMAL_LITERAL: /[0-9]+,[0-9]*/,
    MONEY_AMOUNT: /[0-9]([0-9 ]*[0-9])?(,[0-9]{0,2})? *€/,
    DIVMONEY: '/€',
    GREATER_EQUAL_MONEY: '>=€',
    GREATER_MONEY: '>€',
    LESSER_EQUAL_MONEY: '<=€',
    LESSER_MONEY: '<€',
    MINUSMONEY: '-€',
    MULTMONEY: '*€',
    PLUSMONEY: '+€',
    LAW_INCLUDE: 'Inclusion',
  },
  pl: {
    SCOPE: "zakres",
    CONSEQUENCE: "konsekwencja",
    DATA: "data",
    DEPENDS: "zalezy\s+od",
    DECLARATION: "deklaracja",
    CONTEXT: "kontekst",
    DECREASING: "malejacy",
    INCREASING: "rosnacy",
    OF: "z",
    COLLECTION: "kolekcja",
    CONTAINS: "zawiera",
    ENUM: "enumeracja",
    INTEGER: "calkowita",
    MONEY: "pieniądze",
    TEXT: "tekst",
    DECIMAL: "dziesiętny",
    DATE: "czas",
    DURATION: "czas\s+trwania",
    BOOLEAN: "zerojedynkowy",
    SUM: "suma",
    FILLED: "spelnione",
    DEFINITION: "definicja",
    STATE: "stan",
    LABEL: "etykieta",
    EXCEPTION: "wyjątek",
    DEFINED_AS: "wynosi",
    MATCH: "pasuje",
    WILDCARD: "cokolwiek",
    WITH: "ze\s+wzorem",
    UNDER_CONDITION: "pod\s+warunkiem",
    IF: "jezeli",
    THEN: "wtedy",
    ELSE: "inaczej",
    CONDITION: "warunek",
    CONTENT: "typu",
    STRUCT: "struktura",
    ASSERTION: "asercja",
    VARIES: "rozna",
    WITH_V: "wraz\s+z",
    FOR: "dla",
    ALL: "wszystkie",
    WE_HAVE: "mamy",
    FIXED: "staloprzecinkowa",
    BY: "przez",
    RULE: "zasada",
    EXISTS: "istnieje",
    IN: "in",
    SUCH: "takie\s+ze",
    THAT: "to",
    AND: "i",
    OR: "lub",
    XOR: "xor",
    NOT: "nie",
    MAXIMUM: "maximum",
    MINIMUM: "minimum",
    FILTER: "filtr",
    MAP: "mapuj",
    INIT: "poczatkowy",
    CARDINAL: "liczba",
    YEAR: "rok",
    MONTH: "miesiac",
    DAY: "dzien",
    TRUE: "prawda",
    FALSE: "falsz",
    INPUT: "wejście",
    OUTPUT: "wyjście",
    INTERNAL: "wewnętrzny",
    RoundDecimal: "zaokrąglony_dziesiętny",
    RoundMoney: "zaokrąglony_pieniądze",
    IntToDec: "calkowita_wers_dziesiętny",
    MoneyToDec: "pieniądze_wers_dziesiętny",
    DecToMoney: "dziesiętny_wers_pieniądze",
    GetDay: "dostęp_dzień",
    GetMonth: "dostęp_miesiąc",
    GetYear: "dostęp_rok",
    FirstDayOfMonth: "pierwszy_dzień_miesiąca",
    LastDayOfMonth: "ostatni_dzień_miesiąca",
    DECIMAL_LITERAL: /[0-9]+\.[0-9]*/,
    MONEY_AMOUNT: /[0-9]([0-9,]*[0-9])?(\.[0-9]{0,2})? *PLN/,
    DIVMONEY: '/$',
    GREATER_EQUAL_MONEY: '>=$',
    GREATER_MONEY: '>$',
    LESSER_EQUAL_MONEY: '<=$',
    LESSER_MONEY: '<$',
    MINUSMONEY: '-$',
    MULTMONEY: '*$',
    PLUSMONEY: '+$',
    LAW_INCLUDE: 'Include',
  }
}

// International tokens needing no translation (so far)
const tokens_international = {
  ALT: '--',
  AT_PAGE: /@\s*p.\s*[0-9]+/,
  BEGIN_CODE: token.immediate('```catala'),
  BEGIN_DIRECTIVE: token.immediate('>'),
  BEGIN_METADATA: token.immediate('```catala-metadata'),
  COLON: ':',
  CONSTRUCTOR: /[A-Z][A-Za-z0-9_']*/,
  DIRECTIVE_ARG: /\S+/,
  DIV: '/',
  DIVDEC: '/.',
  DIVDURATION: '/^',
  DOT: '.',
  END_CODE: '```',
  END_DIRECTIVE: '\n',
  EQUAL: '=',
  GREATER: '>',
  GREATER_DATE: '>@',
  GREATER_DEC: '>.',
  GREATER_DURATION: '>^',
  GREATER_EQUAL: '>=',
  GREATER_EQUAL_DATE: '>=@',
  GREATER_EQUAL_DEC: '>=.',
  GREATER_EQUAL_DURATION: '>=^',
  IDENT: /[a-z][a-zA-Z0-9_']*/,
  INT_LITERAL: /[0-9]+/,
  LAW_HEADING: token.immediate(/#+\s*[^\n]+/),
  LAW_TEXT: token.immediate(/\S[^\n]*/),
  LBRACKET: '{',
  LESSER: '<',
  LESSER_DATE: '<@',
  LESSER_DEC: '<.',
  LESSER_DURATION: '<^',
  LESSER_EQUAL: '<=',
  LESSER_EQUAL_DATE: '<=@',
  LESSER_EQUAL_DEC: '<=.',
  LESSER_EQUAL_DURATION: '<=^',
  LPAREN: '(',
  LSQUARE: '[',
  MINUS: '-',
  MINUSDATE: '-@',
  MINUSDEC: '-.',
  MINUSDURATION: '-^',
  MULT: '*',
  MULTDEC: '*.',
  NOT_EQUAL: '!=',
  PERCENT: '%',
  PLUS: '+',
  PLUSDATE: '+@',
  PLUSDEC: '+.',
  PLUSDURATION: '+^',
  PLUSPLUS: '++',
  RBRACKET: '}',
  RPAREN: ')',
  RSQUARE: ']',
  SEMICOLON: ';',
  VERTICAL: '|',
}

const tokens = Object.assign({}, tokens_local[lang], tokens_international)

const inline = $ => [
  // $.law_text,
]

const word = $ => $.IDENT

const rules = {
  COMMENT: $ => seq('#', /[^\n]*/),
  _newline: $ => /[ \t]*\r?\n[ \t]*/,
  // newline tokens need to be explicit outside of code blocks, to properly
  // detect beginnings of lines; add them to the choice of toplevel items and make all tokens "immediate"
  // _law_line: $ => prec(0,seq($.LAW_TEXT, $._newline)),
  law_text: $ => prec.right(repeat1(seq($.LAW_TEXT,$._newline))),
  source_file_item: $ =>
      choice($._newline, $.law_text, seq($.BEGIN_CODE, optional($.code), $.END_CODE),
        $.law_heading, $.metadata_block,
        seq($.BEGIN_DIRECTIVE, $.LAW_INCLUDE, $.COLON,
          repeat1($.DIRECTIVE_ARG), optional($.AT_PAGE), $.END_DIRECTIVE)),

  // unhide
  // typ: $ => choice($._typ_base, seq($._collection_marked, $.typ)),
  // _typ: $ => $.typ,
}

const extras = $ => [
  /\s/, $.COMMENT
]
